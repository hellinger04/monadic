# Lesson 1.3: Homegrown Exceptions Pt. 2

In the previous lesson, you probably made a `raise` function that looks like this:

```javascript
function raise() {
  return "Fail!"
}
```

or this

```javascript
function raise() {
  return null;
}
```

And you probably made a `tryWith` function that looks like this:

```javascript
function tryWith(result) {
  if (result === "Fail!") { // or null
    return "Error!";
  } else {
    return result;
  }
}
```

It's clear that this is not exactly the most sophisticated of implementations. Some might even call it a hack! The downsides of this approach are obvious. For starters, lots of things, not just our `raise` function, return `"Fail!"`, so we might catch an excetion where none actually existed.

Instead of using strings or `null` values or whatever, what if we had a custom object for exceptions? Fortunately, we can make our own homegrown custom class called `Exn`:

```javascript
class Exn {}

function raise() {
  return new Exn(); 
}
```

Then on the `tryWith` side of things, we can write:

```javascript
function tryWith(result) {
  // We use instanceof to determine if the result is an Exn object
  if (result instanceof Exn) {
    return "Error";
  } else {
    return result;
  }
}
```

**Problem 1.3.0:** Use this new kind of exception (with the `Exn` class) in the `tryDivide` method.

''''problem
function raise(message) {
  return new Error(message);
}

function tryWith(result) {
  if (result instanceof Exn) return "Error";
  else return result;
}

function tryDivide(x, y) {
  // Your code here
}

// TESTS
// tryDivide(1, 0) instanceof Exn ==> true
// tryWith(tryDivide(10, 2)) ==> 5
// tryWith(tryDivide(100, -100)) ==> -1
// tryWith(tryDivide(134, 0)) ==> Error
''''

**Problem 1.3.1:** As you may know, JavaScript already has its own custom exception object called `Error`. Rework our exceptions to use the `Error` object instead of `Exn` (and make sure `tryWith` still returns `"Error"` upon catching an exception).

''''problem
function raise() {
  // Your code here
}

function tryWith(result) {
  // Your code here
}

// Dev notes: Add test to check that raise returns a Error object

// TESTS
// tryWith(2) ==> 2
// tryWith(Error("Wait, that's illegal!")) ==> Error
// tryWith("FooBar") ===> FooBar
''''

**Problem 1.3.2:** One of the features `Error` has that `Exn` doesn't is that it has a `message` property for error messages. What if we added that feature to `Exn`? Add a `message` field to the `Exn` class, and modify `raise` and `tryWith` to make use of the upgraded `Exn`s. Make sure to follow the comments!

''''problem
class Exn {
  // Your code here
}

// Change raise to take in your error message as an argument
function raise(/* ??? */) {
  // Your code here
}

// Change tryWith to return the error message upon catching an exception
function tryWith(result) {
  // Your code here
}

// Change tryDivide to use the new Exn class
// If a division by zero is encountered, tryDivide should throw an exception with the message "Division by zero encountered!"
function tryDivide(x, y) {
  if (y === 0) {
    // Your code here
  } else {
    return x / y;
  }
}

// TESTS
// raise("Message") instanceof Exn ==> true
// raise("Message").message ==> Message
// tryWith(2) ==> 2
// tryWith("FooBar") ==> FooBar
// tryWith(raise("Uh oh!")) ==> Uh oh!
// tryDivide(2, 2) ==> 1
// tryDivide(2, 0) ==> Division by zero encountered!
''''

**Problem 1.3.3:** Putting error messages inside `Exn` is not the only way of doing them. Modify `tryWith` so that in addition to the result, it also takes in a function `fn` that is called when `tryWith` catches an exception. For simplicity, make `fn` a zero-argument function.

''''problem
// We're using the old Exn for now, for simplicity's sake
class Exn {} 

// We're using the old raise for now
function raise() {
  return new Exn();
}

// New argument!
function tryWith(result, fn) { 
  // Your code here
}

// TESTS
// raise() instanceof Exn ==> true
// tryWith(raise(), () => { return "Oops!"; }) ==> Oops!
// tryWith(2, () => { return "Oops!"; }) ==> 2
''''

# Lesson 2.0: Pulling back the green curtain 

Let's make a general monad so we can get the basic idea about the point. You're going to make a monad from nothing. 

''''problem
function excitedHelloWorld(x) {
    //concat as many exclamation points as you want
    //to x, which will be hello world in this case
    //decide on the amount by how excited you are to
    //be in the world, and return the new string
}

function tellASecret(x) {
  //concat a string that contains a secret you have
  //to whatever x is and return the new string
}

function bestGossip(x) {
    //concat a string with the best gossip you know
    //to x and return the new string
}

function run() {
    x = "Hello World"
    x = excitedHelloWorld(x);
    x = tellASecret(x);
    x = bestGossip(x);
}

console.log(run());


// Dev notes: add test checking for use of Error object?

// TESTS
''''

This is the type of program you are used to and there shouldn't be any
surprises. You can see in the console, you say hello to the world, you see the
secret you told and then you can read the best gossip you know. 

Now, add a function called "wrapper". It should just return x. Then, make a
function called applyFunc that applies the function to the x that you just
wrapped.

''''problem
function excitedHelloWorld(x) {
    //concat as many exclamation points as you want
    //to x, which will be hello world in this case
    //decide on the amount by how excited you are to
    //be in the world, and return the new string
}

function tellASecret(x) {
  //concat a string that contains a secret you have
  //to whatever x is and return the new string
}

function bestGossip(x) {
    //concat a string with the best gossip you know
    //to x and return the new string
}

function run() {
    x = "Hello World"
    x = wrapper(x)
    x = applyFunc(x, excitedHelloWorld);
    x = applyFunc(x, tellASecret);
    x = applyFunc(x, bestGossip);
}

console.log(run());


// Dev notes: add test checking for use of Error object?

// TESTS
''''

This program does the same thing as the last one, but now instead of calling
your functions directly, you pass them to a function that does it for you.
That's a higher order function, because you give the function a function. TODO
explain higher order functions more.



**Problem 1.1.0:** Write a `tryDivide` function that divides two numbers. If a division by zero error is encountered, throw the error message `"division by zero!`. Also write a `divisionByZeroCatch` function that has a `try...catch` block in it to catch any exceptions from `tryDivide`.

''''problem
function tryDivide(x, y) {
  // Your code here
}

function divisionByZeroCatch(x, y) {
  // Your code here
}

// TESTS
// tryDivide(4, 2); ==> 2
// divisionByZeroCatch(2, 4); ==> 0.5
// divisionByZeroCatch(2, 0); ==> division by zero!
''''

**Problem 1.1.1:** It's actually not a good idea to throw raw strings in JavaScript. Instead, the usual way is to throw an `Error` object. Rewrite `tryDivide` and `divisionByZeroCatch` to use `Error` instead of strings (though make sure `divisionByZeroCatch` still returns the same error message as in the previous problem.

''''problem
function tryDivide(x, y) {
  // Your code here
}

function divisionByZeroCatch(x, y) {
  // Your code here
}

// Dev notes: add test checking for use of Error object?

// TESTS
// tryDivide(4, 2); ==> 2
// divisionByZeroCatch(2, 4); ==> 0.5
// divisionByZeroCatch(2, 0); ==> division by zero!
''''

As we see, JavaScript has its own exception handling capabilities. How cute. Letâ€™s rebuild it from scratch, this time in a functional manner!

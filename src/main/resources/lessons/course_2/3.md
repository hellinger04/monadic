# Lesson 2.3: Homegrown Exceptions Pt. 2

In the previous lesson, you probably made a `raise` function that looks like this:

```javascript
function raise() {
  return "Fail!"
}
```

or this

```javascript
function raise() {
  return null;
}
```

And you probably made a `tryWith` function that looks like this:

```javascript
function tryWith(result) {
  if (result === "Fail!") { // or null
    return "Error!";
  } else {
    return result;
  }
}
```

It's clear that this is not exactly the most sophisticated of implementations. Some might even call it a hack! The downsides of this approach are obvious. For starters, lots of things, not just our `raise` function, return `"Fail!"`, so we might catch an excetion where none actually existed.

Instead of using strings or `null` values or whatever, what if we had a custom object for exceptions? Fortunately, we can make our own homegrown custom class called `Exn`:

```javascript
class Exn {}

function raise() {
  return new Exn(); 
}
```

Then on the `tryWith` side of things, we can write:

```javascript
function tryWith(result) {
  // We use instanceof to determine if the result is an Exn object
  if (result instanceof Exn) {
    return "Error";
  } else {
    return result;
  }
}
```

**Problem 1.3.0:** Use this new kind of exception (with the `Exn` class) in the `tryDivide` method.

```problem
///// CODE
class Exn {}

function raise() {
  return new Exn();
}

function tryWith(result) {
  if (result instanceof Exn) {
    return "Error";
  } else {
    return result;
  }
}

function tryDivide(x, y) {
  // Your code here
  if (y === 0) {
    return raise();
  } else {
    return x / y;
  }
}

///// TESTS
// tryDivide(1, 0).constructor.name ==> "Exn"
// tryWith(tryDivide(10, 2)) ==> 5
// tryWith(tryDivide(100, -100)) ==> -1
// tryWith(tryDivide(134, 0)) ==> "Error"
```

**Problem 1.3.1:** One of the features JavaScript's `Error` objects have that `Exn` doesn't is that it has a `message` property for error messages. What if we added that feature to `Exn`? Add a `message` field to the `Exn` class, and modify `raise` and `tryWith` to make use of the upgraded `Exn`s. Make sure to follow the comments!

```problem
///// CODE
class Exn {
  // Your code here
  constructor(message) {
    this.message = message;
  }
}

// Change raise to take in your error message as an argument
function raise(/* ??? */ message) {
  // Your code here
  return new Exn(message);
}

// Change tryWith to return the error message upon catching an exception
function tryWith(result) {
  // Your code here
  if (result instanceof Exn) {
    return Exn.message;
  } else {
    return result;
  }
}

// Change tryDivide to use the new Exn class
// If a division by zero is encountered, tryDivide should throw an exception with the message "Division by zero encountered!"
function tryDivide(x, y) {
  if (y === 0) {
    // Your code here
    return raise("Division by zero encountered!"); 
  } else {
    return x / y;
  }
}

///// TESTS
// raise("Message").constructor.name ==> "Exn"
// raise("Message").message ==> "Message"
// tryWith(2) ==> 2
// tryWith("FooBar") ==> "FooBar"
// tryWith(raise("Uh oh!")) ==> "Uh oh!"
// tryDivide(2, 2) ==> 1
// tryDivide(2, 0) ==> "Division by zero encountered!"
```

**Problem 1.3.2:** Putting error messages inside `Exn` is not the only way of doing them. Modify `tryWith` so that in addition to the result, it also takes in a function `func` that is called when `tryWith` catches an exception. For simplicity, make `func` a zero-argument function (we'll add stuff to it in later lessons).

```problem
///// CODE
// We're using the old Exn for now, for simplicity's sake
class Exn {} 

// We're using the old raise for now
function raise() {
  return new Exn();
}

// New argument!
function tryWith(result, func) { 
  // Your code here
}

///// TESTS
raise().constructor.name ==> "Exn"
tryWith(raise(), () => { return "Oops!"; }) ==> "Oops!"
tryWith(2, () => { return "Oops!"; }) ==> "2"
```

# Lesson 2.5: Wrapping things up?

So far, we have two types of data: `Exn` objects and everything else. So far it works with our exception quasi-monad, but we don't have a true monad since we don't have actual monadic types, monadic variables, or anything fancy like that. We do have a `bind` operation that works on our values, but since it's not working with real monadic types, it's not the same as the `bind` operator in a real monad.

For our exceptions, it seems fine, but it won't work for more complex monads like the state monad, where you have to keep the current state alongside the current value you're working with. After all, the essence of a monad is that it wraps stuff and operates on wrap data. No wrapping means no monads. It's like buying a bowl at Chipotle with a tortilla on the side and calling it a burrito.

(Protip: If you're deciding what to order at Chiptole, you actually get more food in a bowl than in a burrito. So maybe wrapping food isn't all that it's cracked up to be?)

Let's create a class called `Value` that's nothing more except for a wrapper for our regular values:

```javascript
class Value {
  constructor(x) {
    this.x = x;
  }
}
```

And to create a class, we have a wrapper function, which in monad-speak we call `ret`:

```javascript
function ret(x) {
  return new Value(x);
}
```

And we can rewrite our `bind` function to incorporate this new `Value` type:

```javascript
function bind(m, fn) {
  if (m instanceof Exn) {
    return m;
  } else if (m instanceof Value) {
    return fn(m.x);
  }
}
```

Notice how `fn` is a function that takes in the underlying value `m.x`, not `m` itself.

With this idea, we can keep the `raise` the function the same: it still returns a new `Exn`. But `tryWith` will have to be modified.

**Problem 1.5.0:** Modify the `tryWith` function to always return a `Value` object. Expect that `tryWith` will only accept `Exn` and `Value` types.

```problem
///// CODE
class Exn {}

class Value {
  constructor(x) { this.x }
}

function ret(x) { return new Value(x); }

function raise() { return new Exn(); }

function tryWith(m) {
  // TODO: Your code here
}

///// TESTS
tryWith(2).constructor.name ==> "Value"
tryWith(2).x ==> 2
tryWith(raise()).constructor.name ==> "Exn"

///// LANGUAGE
JavaScript
```

If `Value` is a wrapper, then what is `Exn`? Turns out, it can also act as a wrapper! Remember in lesson 1.3 where you added a `message` property to `Exn`? `Exn` serves as a wrapper for that `message` string.

**Problem 1.5.1:** Here we have our enhanced `Exn` class with the `message` property, as well as a `raise` function that takes a message as its argument. But now we also want our enhanced `tryWith` with our new function argument, with some twists:
1. We want `fn` to take in an argument (last time it took in zero arguments).
2. `fn` needs to return a `Value` (since `tryWith` needs to return a `Value`)

```problem
///// CODE
class Exn {
  constructor(msg) { this.message = msg; }
}

class Value {
  constructor(x) { this.x = x; }
}

function ret(x) { return new Value(x); }

function raise(msg) { return new Exn(msg); }

// Write tryWith such that fn needs to take in an argument
// Hint: What's something convenient you can pass into fn? 
function tryWith(m, fn) {
  // TODO: Your code here 
}

// Write a function that can be passed into fn that returns a Value
// Its purpose is to add an extra exclamation point to the string
// Hint: Use the ret operation
function addExclamation(str) {
  // TODO: Your code here
}

// Write a version of tryDivide that returns a Value when successful
// If it's unsuccessful, return an exception with the error message
// "Division by zero encountered"
// (And then tryWith can add the final exclamation point)
function tryDivide(x, y) {
  // TODO:Your code here 
}

///// TESTS
raise("Foo").constructor.name ==> "Exn"
raise("Foo").message ==> "Foo"
tryWith(raise("Uh oh"), x => { return ret(x); }).constructor.name ==> "Value"
tryWith(raise("Uh oh"), x => { return ret(x); }).x ==> "Uh oh"
addExclamation("Foo").constructor.name ==> "Value"
addExclamation("Foo").x ==> "Foo!"
tryWith(raise("Uh oh"), addExclamation).constructor.name ==> "Value"
tryWith(raise("Uh oh"), addExclamation).x ==> "Uh oh!"
tryWith(tryDivide(2, 1), addExclamation).x ==> 2
tryWith(tryDivide(2, 0), addExclamation).x ==> "Division by zero encountered!"

///// LANGUAGE
JavaScript
```
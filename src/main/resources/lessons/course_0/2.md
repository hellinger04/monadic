# Lesson 0.2: Immutability

Here’s an interesting snipped from the map documentation: “map does not mutate the array on which it is called.” This brings us to the next key point of functional programming: *immutability*, or the inability to change data objects after they are created.

In the above case, in functional programming land, you can’t change `arr1` or `arr2` after they have been created. If you wanted to create a new array `arr3`, you’ll have to copy each element from the pre-existing array and then make whatever changes you’d need to make.

(In practice, most functional programming languages are more optimized than this; if you’re creating a new data structure like this, usually they use special “immutable data structures” and don’t copy everything piece by piece.)

This might confuse or even surprise you. Why would you want to have immutability? If you can't change data, doesn’t that make programming less powerful? In a sense, yes. But with great power comes great responsibility. Say that you have a class like this:

```javascript
class MyClass {
    thing = 0;
    function addToThing(x) {thing + x};
}
``` 

When you call `addToThing`, what’s the result? If you pass in `2` as an argument, will you get `2`, `3`, `4`, or `116`? It’s impossible to know for sure, since the result depends on what value the variable thing takes at the moment. And if you change (“mutate”) thing between `addToThing` calls, you’ll get different results. If `MyClass` is part of a larger program, where the value of thing may be changed elsewhere, things (no pun intended) can get out of hand really quickly.

Thus, we have a key idea in functional programming: if you call a function, you’ll always get the same result. If you call `adder` on `2` and `3`, you’ll always get `5`. Not `3`, not `7`, not `"fish"`, but `5`. And it will be like that until the end of time. This, along with immutability, is quite useful in avoiding bugs caused by stateful programming.

But wait! Since we clearly don’t want mutable objects or variables like `thing`, how do we create immutable objects in JavaScript? Arent' objects and variables in JavaScript mutable? Yes, which is why immutability can be quite tricky in a language like JavaScript.

The simplest way is programmer discipline - just don’t mutate objects, not even once. Obviously, willpower is nothing if not fickle, so let’s find a better way.

To simulate immutability, we can use `Object.freeze`, which can take in any object and makes it so that mutations aren’t allowed anymore.

```javascript
let foobar = { x = 24 }
Object.freeze(foobar);
foobar.x = 25; // THIS WILL NOT WORK
```

Perhaps the most seamless approach is to use a third-party library to add immutable data structures. For this reason, we have incorporated Immutable.js as a library to add immutable data structures.

Also, since mutable objects like `thing` are a thing (again, no pun intended) in JS, does that mean that JS isn’t functional? That’s true, sort of. JavaScript and Python have functional programming concepts built into them, but since you can do non-functional programming in them as well, they’re not *pure* functional programming languages.

In a pure functional language like Haskell, any mutations and other non-functional stuff are prohibited. But in JavaScript, you can choose when to use functional programming and when not to, making it very flexible (some would say too flexible). In fact, Haskell is somewhat unusual in being a pure functional language. Most functional programming languages, such as OCaml and Clojure, have ways to implement non-functional stuff (though the non-functional stuff is less emphasized than in JS or Python), making them non-pure functional as well.

Anyways, back to immutable data structures. You might be wondering how you can do things without mutating objects. The key is that even though you can’t mutate existing variables or objects, you can create new data using immutable data. Take a look at this code:

```javascript
// List is an immutable object from Immutable.js
const list1 = List([1, 2, 3]);
const list2 = list1.map(x => x * 2);
// Expected result: list2 = [2, 4, 6]
``` 

As said before, `map` doesn’t mutate the array that it’s called on. Instead, it creates a new array out of the old one. Now we have two objects, `list1` and `list2`, running around. The `List` object is the same as it was before, as it is immutable thanks to freeze.

This has an odd result of making iteration as we know it, such as for and while loops, impossible. Take a look at this non-functional implementation of the map function:

```javascript
// Okay, it takes in a function as an arg so it’s a higher order
// function. But it requires mutation so it’s not purely functional.
function mapNotFunctional(array, fn) {
	for (int i = 0; i < array.length; i++) {
		let value = array[i];
		array[i] = fn(value);
	}
}
``` 

In our for loop, we need to mutate our index `i` (in this case by incrementing it). If we don’t mutate it, `i` will be stuck at the same value and your loop will run forever. It’s even worse with while loops, since while loops check whether some value has met a certain condition; if you can’t change that value, the while loop will either run forever (since it never meets that condition) or not run at all (since it has met that condition at the start of the loop).

Not to mention, in `mapNotFunctional`, we’ve mutated array on the line `array[i] = fn(value)`, so our function is doubly not-functional.

In functional programming languages, you have to use recursion in order to perform iteration. Recursion is when you call a function from within itself. Here is an implementation of `map` that uses recursion instead of iteration:

```javascript
function mapFunctional(fn, list) {
    last = list.last();
    rest = list.pop();
    if (last === undefined) {
        return List();
    } else {
        let newLast = fn(last);
        let newRest = mapFunctional(fn, rest);
        return newRest.push(newLast);
    }
}
```

(Inspired by code from https://www.freecodecamp.org/news/implement-array-map-with-recursion-35976d0325b2/)

Here, instead of a default JS array, which is mutable, `mapFunctional` takes in Immutable.js's `List` object as one of its arguments. We split the list into its last element and the rest of the elements (still in `List` form). We check if the last element of the list is undefined, ie. if it doesn’t exist. If that’s the case, we return an new `List` object.

Otherwise, we use take the last value and pass it to `fn`, which returns `newLast`. To create `newRest`, we call `mapFunctional` again, now from inside the body of `mapFunctional`! It may be tricky to wrap your head around this if you’re not used to recursion, but just trace these calls of `mapFunctional` all the way down.

If our list is empty, we return an empty list.

If our list only has a single element in it, `mapFunctional` calls itself on `rest` to create an empty list, and then appends `newLast` to it.

If our list has two elements, `mapFunctional` calls itself to create a one-element list, and then appends `newLast` to it to create a new, two-element list.

Note that throughout this function, we have not mutated a single `List` objects. We’ve only created new lists from old ones. Such is the power of functional programming, recursion, and immutability!

**Exercise 0.2.0:** You may have heard of “map-reduce,” and we’ve covered the map part of that. Now we do the reduce part, or at least a variant of reduction called a fold.

Write a function `foldFunctional` that takes in three arguments:

- A two argument function
- An accumulator, which can be of any value (though it has to make sense for the function and the List)
- A `List`

Your `foldFunctional` will run the input function repeatedly over the accumulator and each element of the List, and will return the final value of the accumulator as a result. For example, if `adder` is your function, `0` is your accumulator, and `[1, 2, 3]` is your list, you should end up with the number `6` as your output (since 1 + 2 + 3 = 6).

You should not mutate the value of any pre-existing accumulator; you can only create new accumulator instances. You also can't mutate your `List` since it's an Immutable.js object. Furthermore, you should not use for or while loops; use recursion only.

**Exercise 0.2.1:** Create a function `filterFunctional` that takes two arguments:

- A predicate, ie. a function that takes in a single argument and returns true or false.
- A `List`

Your `filterFunctional` will run the predicate repeatedly over each element in the list. The output is a new `List` where only elements that make the predicate return `true` exist. For instance, if `greaterThan2` is your predicate and `[1, 3, 2, 5, 7]` is your `List`, then `filterFunctional` should return `[3, 5, 7]`.

Again, you should not mutate the `List`, nor should you use for or while loops.

# Lesson 0.3: Side Effects

Mutations are an example of side effects. What are side effects? For a function, we have a return value; anything that a function does that isn’t that calculating or returning a value is a side effect.

For this reason, we can distinguish pure from impure functions. A pure function is a function that has no side effects. Remember adder, that function that added two numbers, returned the sum, and did nothing else? That is an example of a pure function. You can still do crazy things with pure functions, such as creating new (immutable) objects like there’s no tomorrow or calculating the trillionth digit of pi, but if there is nothing coming out of the function except for that return value, it’s a pure function.

An example of an impure function would be mapNotFunctional from the previous lesson. That function is impure because it mutated the loop index i while it was doing its thing. Mutation is an example of a side effect because it’s a change in the program’s state that isn’t the return value. On the other hand, since mapFunctional doesn’t have mutation or any other side effects, it is a pure function.

Now that we have an idea of what side effects and pure/impure functions are, what are some examples of side effects?

- Mutation and state changes: We have already covered that. Basically, whenever a program mutates a pre-existing variable, it is changing the state of the program, which consists in part of the variables floating around in the program.

- I/O and printing: Whenever you’re printing a value to the command line, you never do it by having a function return it, right? Instead, you call another function, such as print or console.log, to print it, and you do something similar for reading and writing files. Since print statements and file I/O are not return values, they are side effects.

- Exceptions: Whenever you raise an exception, you never do so as a return value. Instead, exceptions generally allow you to exit a function before you reach the return statement. As such, they also count as side effects.

As we have seen with mutations, side effects are something to avoid with functional programming, since they can introduce bugs and greatly increase the complexity of your program. Like, are you sure that your function will return a value instead of blowing up by raising an exception? Are you sure that your function will always return the number 24? Maybe you need that function to return 24, because you’re feeding that number to another function that raises an exception if it gets anything besides 24 (perhaps it’s from a date and time library).

And sometimes, like when you’re programming in Haskell, you can’t have side effects because your whole damn language is pure functional.

That is where monads come in. Monads allow you to have a space in your program where you can do all the side effects you want, and then come back to pure functional land once you’re done messing around with them. In other words, they allow you to encapsulate your side effects. In fact, the way Haskell does I/O is through a monad!

Motivated enough? We hope so, so why not jump right into Monadland?
# Lesson 3.3: The State Monad

Recall the Counter monad:

```typescript
type Mon<A> = (c: number) => [A, number]

function ret<A>(n: A): Mon<A> {
    return function(c: number) { return [n, c]; }
}

function bind<A, B>(m: A, fn: (n: A) => Mon<B>): Mon<B> {
    return function(c: number) {
        let [x, nc] = m(c);
        return f(x)(nc);
    }
}

function tick<A>(m: Mon<A>): Mon<A> {
    return function(c: number) { return m(c + 1); }
}
```

and the Logger monad:

```typescript
type Mon<A> = (l: string[]) => [A, string[]];

function ret<A>(a: A): Mon<A> {
    return function (l: string[]) { return [a, l]; }
}

function bind<A, B>(m: Mon<A>, fn: (a: A) => Mon<B>): Mon<B> {
    return function (l: string[]) {
        let [x, nl] = m(l);
        return fn(x)(nl);
    }
}

function run<A>(m: Mon<A>): [A, string[]] {
    return m([]);
}

function log(msg: string): Mon<null> {
    return function (l: string[]) {
        // Need to create deep copy of array
        let nl = Array.from(l);
        nl.push(msg);
        return [null, nl];
    }
}
```

Both monads consist of operations that, for the most part, return functions that in turn return tuples. Each tuple is a pair containing a value and either a number (in the case of the Counter monad) or an array (in the case of the Logger monad).

But we can go even further than that. What if instead of a number or an array, we used a map? (And if you don't know what a map is - what are you, casual?)

We already have our array of strings from the Logger monad. Now, imagine if we added an integer key to each of these strings, so that we can instantly access any of the logs (or whatever the strings are supposed to represent)?

As you can imagine, we don't really have to change the core monad operations all that much, other than switching around a bunch of types:

```javascript
// `s` is for `store`
type Mon<A> = (s: Map<number, string>) => [A, Map<number, string>]

function ret<A>(a: A): Mon<A> {
    return function(s) {
        return [a, s];
    }
}

function bind<A, B>(m: Mon<A>, fn: (a: A) => Mon<B>) {
    return function(s: Map<number, string>) {
        let [x, ns] = m(s);
        return fn(x)(ns);
    }
}

function run<A>(m: Mon<A>): [A, Map<number, string>] {
    return m(new Map());
}
```

However, how are we going to perform the two most basic operations of any map: get and put? Putting is simple. It's a variation of the `log` function from the Logger monad:

```typescript
function putVal(k: number, v: string): Mon<null> {
    return function(s) {
        s.set(k, v);
        return [null, s];
    }
}
```

Get should also be simple enough. Here's a first pass at it:

```typescript
function getVal(k: number): Mon<string> {
    return function (s) {
        let v = s.get(k);
        return [v, s];
    }
}
```

**Problem 3.3.0:** There's actually a bug in the `getVal` code, which would prevent TypeScript from compiling it. Fix the bug in `getVal`. Hint: what happens if `s` is an empty map?

```problem
///// CODE
function getVal(k: number): Mon<string> {
    // TODO Answer for reference
    return function (s) {
        let v = s.get(k);
        if (v === undefined) {
            return ["", s]
        } else {
            return [v, s];
        }
    }
}

///// TESTS
let map = new Map<number, string>().set(2, "foo"); getVal(2)(map)[0] ==> foo
let map = new Map<number, string>(); getVal(2)(map)[0] ==> ""
let map = new Map<number, string>(); getVal(2)(map)[1].length ==> 0
```

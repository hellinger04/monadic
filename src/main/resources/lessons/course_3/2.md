# Lesson 3.2: Writer monad

From the previous lesson, we have the Counter monad:

```typescript
type Mon<A> = (c: number) => [A, number]

function ret<A>(n: A): Mon<A> {
    return function(c) { return [n, c]; }
}

function bind<A, B>(m: A, fn: (n: A) => Mon<B>): Mon<B> {
    return function(c) {
        let [x, nc] = m(c);
        return f(x)(nc);
    }
}

function tick<A>(m: Mon<A>): Mon<A> {
    return function(c) { return m(c + 1); }
}
```

And for the Fibonacci problem, you should've gotten something like this:

```typescript
function fibonacci(n: number): Mon<number> {
    return bind(tick(ret(n)), _ => {
        if (n === 0 || n === 1) {
            return ret(1);
        } else {
            return bind(fibonacci(n - 1), n1 => {
                return bind(fibonacci(n - 2), n2 => {
                    return ret(n1 + n2);
                })
            });
        }
    });
}
```

Notice how instead of explicitly threading the state as a function argument, we are implicitly doing so using the `bind` method.

Of course, we can do more than just counting. Suppose that instead of a number, we had an array, and instead of incrementing we had appending. Let's see how this works out.

**Problem 3.2.0:** Rework the Counter monad to become a Logger monad: instead of passing around a single number, we pass around a list of strings that we increment.

Hint 1: To give you an idea of what you're doing, we did the `log` and `run` operations for you. The `log` operation returns a function that appends a new string to the log.
 
Hint 2: There's surprisingly little you need to change in the remaining operations, `ret` and `bind`.

```problem
///// CODE
type Mon<A> = (l: string[]) => [A, string[]];

function ret<A>(a: A): Mon<A> {
    // Your code here 
}

function bind<A, B>(m: Mon<A>, fn: (a: A) => Mon<B>): Mon<B> {
    // Your code here 
}

function run<A>(m: Mon<A>): [A, string[]] {
    return m([]);
}

function log(msg: string): Mon<null> {
    return function (l: string[]) {
        l.push(msg);
        return [null, l];
    }
}

///// TESTS
typeof ret(2); ==> function
typeof bind(ret(0), _ => ret(1)); ==> function
run(ret(2))[0] ==> 0
run(ret(2))[1].length ==> 0
run(bind(ret(0), x => log("foo")))[0] ==> null
run(bind(ret(0), x => log("foo")))[1][0] ==> foo
run(bind(ret(2), x => bind(log("foo"), _ => ret(x))))[0] ==> 2
run(bind(ret(2), x => bind(log("foo"), _ => ret(x))))[1][0] ==> foo
run(bind(ret(2), x => bind(log("foo"), _ => bind(log("bar"), _ => ret(x)))))[0] ==> 2;
run(bind(ret(2), x => bind(log("foo"), _ => bind(log("bar"), _ => ret(x)))))[1][0] ==> foo;
run(bind(ret(2), x => bind(log("foo"), _ => bind(log("bar"), _ => ret(x)))))[1][1] ==> bar;
```

Yay, we have a list of strings. What can we do with them? One thing we can do is create a log of comments, errors, etc. that we can eventually print out. Usually, we print to a console:

```typescript
function run<A>(m: Mon<A>): A {
    let [result, log] = m([]);
    for (i = 0; i < log.length; ++i) {
        console.log(log[i]);
    }
}
```

But this is JavaScript world. We can do better, such as giving output to a window popup.

**Problem 3.2.1:** Redo `run` such that it prints out every string in the list in a window popup. In addition, the previous code wasn't very functional - redo it in a functional manner (ie. no `for` or `while` loops).

```problem
///// CODE
type Mon<A> = (l: string[]) => [A, string[]];

function run<A>(m: Mon<A>): A {
    // Your code here
}

// TODO Determine if 1) code is function and 2) popup window is displayed

///// TESTS
run(function(l) { return [2, l] })[1].length ==> 0
```

And thus the IO monad was born. No seriously - any IO monad, such as the Logger monad, is simply an example of a State monad, as we will see shortly.

**Problem 3.2.2:** Let's go back to the Fibonacci function. If you've noticed, the number of function calls blows up dramatically for bigger and bigger `n`. Now let's get a visceral sense of that. Use our Logger monad to log each `n` that was called, in order.

Hint: This should be similar to what you did with the Counter monad.

```problem
///// CODE
type Mon<A> = (l: string[]) => [A, string[]];

function ret<A>(a: A): Mon<A> {
    return function (l) {
        return [a, l];
    }
}

function bind<A, B>(m: Mon<A>, fn: (a: A) => Mon<B>): Mon<B> {
    return function (l) {
        let [x, nl] = m(l);
        return fn(x)(nl);
    }
}

function run<A>(m: Mon<A>): [A, string[]] {
    return m([]);
}

function log(msg: string): Mon<null> {
    return function (l: string[]) {
        l.push(msg);
        return [null, l];
    }
}

function fibonacci(n: number): Mon<number> {
    // FIXME Implmenetation provided for reference
    return bind(log(n.toString()), _ => {
        if (n === 0 || n === 1) {
            return ret(1);
        } else {
            return bind(fibonacci(n - 1), n1 => {
                return bind(fibonacci(n - 2), n2 => {
                    return ret(n1 + n2);
                })
            })
        }
    })
}

///// TESTS
run(fibonacci(0))[0] ==> 1
run(fibonacci(1))[0] ==> 1
run(fibonacci(5))[0] ==> 8
run(fibonacci(17))[0] ==> 2584
run(fibonacci(5))[1].length ==> 15
let arr = ["5", "4", "3", "2", "1", "0", "1", "2", "1", "0", "3", "2", "1", "0", "1"]; run(fibonacci(5))[1].every((val, idx) => { return val === array2[idx]; }) ==> true
```
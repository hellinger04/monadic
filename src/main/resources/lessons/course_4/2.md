# Lesson 4.2: call/cc and throw

Remember the continuation monad from the last lesson? 

```javascript
function ret(a) {
  return function(cont) {
    return cont(a);
  }
}

function bind(mon, func) {
  return function(cont) {
    return mon(val => func(val)(cont));
  }
}

function run(mon) {
  return mon(val => val);
}
```
The thing is if you're using the monad, you have no way to access the continuation outside of the monad. The ret part takes the `a`, the work already done, and returns the `cont(a)` to `function(cont)`. Then it returns `function(cont)` to you. But the `function(cont)` is the wrapper. You can't access what's inside the wrapper. You get `function(cont)` but you don't have the `cont`. You can't access the rest of the
continuation.

So what you need to access `cont` is to go into some sort of God mod. Luckily, you can do that with `call/cc`! call/cc stands for _call with current continuation_. The reason it's called that is that if you call _call/cc_, then you will have access to the continuation and you can do whatever you want. Basically, you have become God.

```javascript
function callcc(func) {
  return function(cont) {
    return (func(cont))(cont);
  }
}
```

`callcc` takes a function, `func` that itself is in the form of `function(cont)`. So `callcc` is taking a function that has a parameter that is a function with a continuation. How convenient that this is what you got back from ret or bind or any other function in the monad! That is the contract you signed. Everything has to be in the form function(continuation) otherwise you broke the monad and you will be sad.

Now let's talk about why `func` gets two continuations. The first application of `cont` to `func` gives the global continuation to `func`. The global continuation is the continuation that we have been passing along this whole time, before we called `callcc`. The second application of `cont` is then passed into the result of `(func(cont))` (which itself returns a `function(cont)`).  This is to give that function the global continuation if `func(cont)` did not do anything special to `cont`. 

But what if something did happen to `cont`? We have yet another operation called `throw`.

```javascript
function throw(cont, x) {
  return function(cont) {
    return cont(x);
  }
}
```

`throw` is if something went wrong, just like if you throw an exception (remember `raise` in the exception monad?). `throw` means throw whatever you have on the ground, out the window, under the bus, or anywhere else, and return something different instead. Once you call `throw` in a continuation, the `throw` gets passed along, and if you keep calling the same continuation, it will keeping returning your custom `x`. `x` is your custom "work that is already done" which is different from the work you've actually already done. You threw out the actual work you've already done.

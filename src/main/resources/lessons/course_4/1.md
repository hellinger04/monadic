# Lesson 4.1: The Continuation Monad Structure

Since this course is part of a monad tutorial, you're probably wondering: can we make a monad for continuations? 

Answer: Hell yes! Here it is:

```javascript
function ret(a) {
    return function(cont) {
        return cont(a);
    }
}

function bind(mon, func) {
    return function(cont) {
        return mon(val => func(val)(cont));
    }
}

function run(mon) {
    return mon(val => val);
}
```

_SAY WHAAAT???_

To understand what this is doing, imagine each operation works as a mini assembly line. The first worker does their part. Then, the pass on the results of what they did to the second worker, who then does their part, then passes on their result to the third worker and on and on and on and on and on. 

The other important thing to remember, is, unlike a normal program, where a function pops of the stack with the result and returns, you never return from a continuation. You don't need a stack. It never pops off. Once you pass a value to the continuation, there is only one way to go, which is down, deeper into the continuation.

Let's first look at `ret`:
```javascript
function ret(a) {
    return function(cont) {
        return cont(a);
    }
}
```

Like any other `ret`, this `ret` takes in some random thing (the `a`) as an argument and wraps it as a monadic value. In this case, the monadic value is a function that takes a continuation as an argument, and returns `a` applied to that continuation.

Yes, just like you can pass values to a continuation, like in the previous lesson, you can pass continuations as arguments into other functions. That's because continuations are simply represented as functions here.

Let's recall an example from the last lesson:

```javascript
let ourCont = function(v) {
    return v * (3 + 4);
}
```

In the last lesson, `v` had the value `3`. In our monad, that would be like:

```javascript
ret(3);
```

Where we wrap `3`, the work that we have already did. Then `ret` will return its function:

```javascript
function(cont) {
    cont(3);
}
```

If we pass `ourCont` to that function, then in the function body `ourCont` will get `3` as an argument. Then `ourCont` will evaluate `3` on `v * (3 + 4)`, which is the rest of the work, and we get back our final result, which is `3 * (3 + 4) = 21`.

So that is how `ret` works. As you can see, it is very much like an assembly line, where each function functions (he he) like a worker that gets an argument from the last worker and returns a value to be used by the next worker.

Now that we explained `ret`, let's look at `bind`:

```javascript
function bind(mon, func) {
    return function(cont) {
        return mon(val => func(val)(cont));
    }
}
```

We can keep going with the assembly line analogy.

0: Some continuation gets passed into `function(cont) { ... }`.

1: We pass `val => func(val)(cont)` to `mon` (the monadic value). Remember that `mon` has the form `function(cont) { ... }`, so the value we passed in is a continuation. We then get a new value, which is `(val => func(val)(cont))(a)`.

2: We pass `a` into the lambda function, so we end up with `func(a)(cont)`.

3: Because `func` is used in `bind`, it always returns something of the form `function(cont){ ... }`, ie. a monadic value. Thus, `func(a)` returns a function that takes in the next `cont` as an argument.

4: `cont` is passed into the function. The value of `a`, the work already done, is applied to `cont`, the rest of the work.

```javascript
function run(mon) {
    return mon(x => x);
}
```





If you notice, both `ret` and `bind` return a function of form `function(cont) {
    ... }`, ie. they are functions that take in continuations as their argument.

Continuations are just like life. You can only do the rest of the work and you can never pop off the stack.
